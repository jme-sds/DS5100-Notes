% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Programming for Data Science Notes},
  pdfauthor={John Michael Epperson},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Programming for Data Science Notes}
\author{John Michael Epperson}
\date{}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\chapter{About}\label{about}

These are my notes for DS 5100: Programming for Data Science, Fall 2024 as taught by Professor Raf Alvarado.

\chapter{Introducing Python}\label{introducing-python}

Data structures in a nutshell:

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Data Structure & Ordered & Mutable & Constructor & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
List & Yes & Yes & \texttt{{[}{]}} or \texttt{list()} & \texttt{{[}5.7,4,\textquotesingle{}yes\textquotesingle{}5.7{]}} \\
Tuple & Yes & No & \texttt{()} or \texttt{tuple()} & \texttt{(5.7,4,\textquotesingle{}yes\textquotesingle{}5.7)} \\
Set & No & Yes & \texttt{\{\}} or \texttt{set()} & \texttt{\{5.7,\ 4,\ \textquotesingle{}yes\textquotesingle{}\}} \\
Dictionary & No & No & \texttt{\{\ \}} or \texttt{dict()} & \texttt{\{\textquotesingle{}Jun\textquotesingle{}:75,\textquotesingle{}Jul\textquotesingle{}:89\}} \\
\end{longtable}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& Ordered & Unordered \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutable} & List \texttt{{[}{]}} & Set \texttt{\{\}} \\
\textbf{Immutable} & Tuple \texttt{()} & Dict \texttt{\{\ \}} \\
\end{longtable}

\chapter{Control Structures}\label{control-structures}

\textbf{Structures} control the flow of data in a program.

These structures are made of code blocks that provide \textbf{looping and branching} capabilities to your code, based on \textbf{boolean conditions}.

\section{Control Structures General}\label{control-structures-general}

\subsection{Conditions}\label{conditions}

I think you already know this, here's a simple example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{val }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{2}

\ControlFlowTok{if}\NormalTok{ val }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(val)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\OperatorTok{{-}}\NormalTok{val)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
\end{verbatim}

\subsection{Indentation}\label{indentation}

Is essential to a python program.

\begin{itemize}
\tightlist
\item
  Python gets rid of the curly brackets and \texttt{IF...END\ IF} statements of c-like languages and replaces them with a consistent indentation pattern. This created more readable, easier to type code.
\end{itemize}

\subsubsection{\texorpdfstring{\textbf{\texttt{elif}}}{elif}}\label{elif}

\texttt{elif} is reached when previous statements are not.

Unlike a series of \texttt{if} statements, an \texttt{elif} statement is \textbf{only} processed if none of the preceding `if' statements are \textbf{not processed}. See example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{val }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{2}

\ControlFlowTok{if} \OperatorTok{{-}}\DecValTok{10} \OperatorTok{\textless{}}\NormalTok{ val }\OperatorTok{\textless{}} \OperatorTok{{-}}\DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}bucket 1\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{elif} \OperatorTok{{-}}\DecValTok{5} \OperatorTok{\textless{}=}\NormalTok{ val }\OperatorTok{\textless{}} \OperatorTok{{-}}\DecValTok{2}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}bucket 2\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ val }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{2}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}bucket 3\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## bucket 3
\end{verbatim}

\subsubsection{\texorpdfstring{\textbf{\texttt{else}}}{else}}\label{else}

\texttt{else} can be used as a catchall for situations where no condition is met. Put it at the end.

It's good practice to include and \texttt{else} statement.

\subsubsection{\texorpdfstring{\texttt{if} and \texttt{else} statements as one-liners}{if and else statements as one-liners}}\label{if-and-else-statements-as-one-liners}

Python provides a short-hand way of defining \texttt{if} statements:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}

\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}odd\textquotesingle{}}\NormalTok{) }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1} \ControlFlowTok{else} \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}even\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## odd
\end{verbatim}

The general form:

\texttt{ACTION1\ if\ CONDITION\ else\ ACTION2}

both \texttt{if} and \texttt{else} are required. Otherwise, code machine broke\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}odd\textquotesingle{}}\NormalTok{) }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## expected 'else' after 'if' expression (<string>, line 1)
\end{verbatim}

Basically it's either/or

\subsubsection{Using mulitple conditions}\label{using-mulitple-conditions}

I think you got this one chief. Make sure you use parentheses to keep order of operations in tact.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\NormalTok{) }\ControlFlowTok{if}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{2} \OperatorTok{\textless{}}\NormalTok{ val }\OperatorTok{\textless{}} \DecValTok{2}\NormalTok{) }\KeywordTok{or}\NormalTok{ (val }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{) }\ControlFlowTok{else} \BuiltInTok{print}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
\end{verbatim}

\subsection{Loops}\label{loops}

Loops are \textbf{fundamental} to constructs in programming.

The repitition of a process as the data changes is called \textbf{iteration}.

Loops exemplify a \textbf{premise} of this course that data structures imply algorithms. Using the term `list' broadly, we may say that \textbf{lists imply loops}.

The two main kinds of loops in python are \texttt{while} and \texttt{for}.

\subsubsection{\texorpdfstring{\texttt{while} loops}{while loops}}\label{while-loops}

While loops iterate `while' some condition is true. they stop when the condition is false.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ix }\OperatorTok{=} \DecValTok{1}
\NormalTok{ix\_list }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{while}\NormalTok{ ix }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
\NormalTok{    ix }\OperatorTok{*=} \DecValTok{2}
\NormalTok{    ix\_list.append(ix)}
\BuiltInTok{print}\NormalTok{(ix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ix\_list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [2, 4, 8, 16]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ix\_list[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 16
\end{verbatim}

Note that it is possible for while loops to be unending.

For example:

\texttt{while\ 1:\ \textbackslash{}\ \ \ print("This\ is\ so\ annoying")}

This is why it's important to make sure your looping condition can be met. You may also break out of a loop by other means.

\subsubsection{\texorpdfstring{\texttt{break}}{break}}\label{break}

Sometimes you want to quit the loop early, if some condition is met.

To do this, put \texttt{break} in the \texttt{if} statement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ix }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ ix }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
\NormalTok{    ix }\OperatorTok{=}\NormalTok{ ix }\OperatorTok{*} \DecValTok{2}
    \ControlFlowTok{if}\NormalTok{ ix }\OperatorTok{==} \DecValTok{4}\NormalTok{:}
        \ControlFlowTok{break}
\BuiltInTok{print}\NormalTok{(ix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4
\end{verbatim}

The \texttt{break} causes the loop to end early.

\subsubsection{\texorpdfstring{\texttt{continue}}{continue}}\label{continue}

Sometimes you want to introduce skipping behavior in loops.

In this case, use \texttt{continue} in \texttt{if} statement.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ix }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ ix }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
\NormalTok{    ix }\OperatorTok{=}\NormalTok{ ix }\OperatorTok{*} \DecValTok{2}
    \ControlFlowTok{if}\NormalTok{ ix }\OperatorTok{==} \DecValTok{4}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}skipping 4...\textquotesingle{}}\NormalTok{)}
        \ControlFlowTok{continue}
    \BuiltInTok{print}\NormalTok{(ix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
## skipping 4...
## 8
## 16
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{for}}{for}}\label{for}

In contrast to \texttt{while} loops, \texttt{for} loops iterate over an iterable data structure, such as a list.

They stop once the list is finished. See example below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cities }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Charlottesville\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}New York\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}SF\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}BOS\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}LA\textquotesingle{}}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ city }\KeywordTok{in}\NormalTok{ cities:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}"}\SpecialCharTok{\{}\NormalTok{city}\SpecialCharTok{.}\NormalTok{lower()}\SpecialCharTok{\}}\SpecialStringTok{"\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## "charlottesville" "new york" "sf" "bos" "la"
\end{verbatim}

Conditions can be placed inside \texttt{if} statements to skip within or stop the loop.

\textbf{e.g.}: Quit early if \texttt{SF} reached, using \texttt{break}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cities }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Charlottesville\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}New York\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}SF\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}BOS\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}LA\textquotesingle{}}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ city }\KeywordTok{in}\NormalTok{ cities:  }
    \ControlFlowTok{if}\NormalTok{ city }\OperatorTok{==} \StringTok{\textquotesingle{}SF\textquotesingle{}}\NormalTok{:}
        \ControlFlowTok{break}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}"}\SpecialCharTok{\{}\NormalTok{city}\SpecialCharTok{.}\NormalTok{lower()}\SpecialCharTok{\}}\SpecialStringTok{"\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## "charlottesville" "new york"
\end{verbatim}

Skip over \texttt{SF} if reached, using \texttt{continue}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cities }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Charlottesville\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}New York\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}SF\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}BOS\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}LA\textquotesingle{}}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ city }\KeywordTok{in}\NormalTok{ cities:}
    \ControlFlowTok{if}\NormalTok{ city }\OperatorTok{==} \StringTok{\textquotesingle{}SF\textquotesingle{}}\NormalTok{:}
        \ControlFlowTok{continue}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}"}\SpecialCharTok{\{}\NormalTok{city}\SpecialCharTok{.}\NormalTok{lower()}\SpecialCharTok{\}}\SpecialStringTok{"\textquotesingle{}}\NormalTok{, end}\OperatorTok{=}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{)        }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## "charlottesville" "new york" "bos" "la"
\end{verbatim}

\subsection{\texorpdfstring{\texttt{while} vs \texttt{for}}{while vs for}}\label{while-vs-for}

When choosing between a \texttt{for} and \texttt{while} loop, consider the following:

\begin{itemize}
\item
  \texttt{for} loops are used to loop through a list of values or an operation in which the number of iteration is \textbf{known} in advance.
\item
  \texttt{while} loops are used when you \textbf{don't know} how many iterations it will take - you are depending on some condition to be met.
\end{itemize}

The former is often used when \textbf{processing} data, the latter whe performing algorithmic \textbf{modeling} tasks, such as optimizing and convergence.

\section{Iterables and Iterators}\label{iterables-and-iterators}

Sequential data structures like lists and tuples have a \textbf{natural affinity} to loops.

Sequences imply loops, and loops expect sequences.

In python this relationship is captured by the resonance between the words \textbf{iteration} and \textbf{iterables}.

\textbf{Iterable data structures} that can be iterated over, meaning they can return their elements one at a time.

\textbf{Examples} of iterable objects include lists, tuples, sets, dicts, and strings.

Typically we iterate over iterables using \texttt{for} \textbf{loops}, as we saw when we reviewed control structures.

\subsection{Lists}\label{lists}

\subsubsection{\texorpdfstring{iterating using \texttt{for}}{iterating using for}}\label{iterating-using-for}

review of iteration by means of a \texttt{for} loop

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tokens }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}living room\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}was\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}quite\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}large\textquotesingle{}}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ tok }\KeywordTok{in}\NormalTok{ tokens:}
    \BuiltInTok{print}\NormalTok{(tok)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## living room
## was
## quite
## large
\end{verbatim}

\subsubsection{Iterators}\label{iterators}

An \textbf{iterator} is used to iterate over iterable objects by removing one element at a time from the iterables.

\subsubsection{Iterating with Iterators}\label{iterating-with-iterators}

An iterator works by popping out and removing a value at each iteration.

This means that when iterating through an iterable object you empty as you go, leaving an empty data structure at the end.

This is useful in situations where you want to save memory.

Many functions in python return iterables so it's helpful to understand them even if you don't create any yourself.

\subsubsection{\texorpdfstring{Using \texttt{iter()} and \texttt{next()}}{Using iter() and next()}}\label{using-iter-and-next}

convert a sequence to an iterator object using \texttt{iter()}

Then use \texttt{next()} to get the next item from the iterator.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tokens }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}living room\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}was\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}quite\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}large\textquotesingle{}}\NormalTok{]}
\NormalTok{myit }\OperatorTok{=} \BuiltInTok{iter}\NormalTok{(tokens)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(myit)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## living room
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(myit)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## was
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(myit)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## quite
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(myit)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## large
\end{verbatim}

Calling \texttt{next()} when the iterator has reached the end of the list produces an exception:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{next}\NormalTok{(myit)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## StopIteration
\end{verbatim}

Note that when used witha n iterable created by \texttt{iter()}, \texttt{for} implicitly executes \texttt{next()} on each loop iteration.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myit }\OperatorTok{=} \BuiltInTok{iter}\NormalTok{(tokens) }\CommentTok{\# Reset the iterator}
\ControlFlowTok{for}\NormalTok{ next\_it }\KeywordTok{in}\NormalTok{ myit:}
    \BuiltInTok{print}\NormalTok{(next\_it)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## living room
## was
## quite
## large
\end{verbatim}

\subsection{Sequences and Collections}\label{sequences-and-collections}

So far, we've iterated over a list; now we'll look at sets, strings, tuples, dicts, and ranges!

Lists, tuples, and strings are \textbf{sequences}. Sequences are designed so that elements come out of them the same way they were put in (they are ordered).

Sets and dictionaries are not sequences per se, since the order of their elements is not as important as their names. Sets and dicts are called \textbf{collections}.

Post Python 3.7, dicts preserve order, and sets are sorted; but it don't matter too much.

\subsubsection{Sets}\label{sets}

Iterating using \texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{princesses }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}belle\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cinderella\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rapunzel\textquotesingle{}}\NormalTok{\}}
\ControlFlowTok{for}\NormalTok{ princess }\KeywordTok{in}\NormalTok{ princesses:}
    \BuiltInTok{print}\NormalTok{(princess)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## cinderella
## rapunzel
## belle
\end{verbatim}

Now with \texttt{iter()} and \texttt{next()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{princesses\_i }\OperatorTok{=} \BuiltInTok{iter}\NormalTok{(princesses)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(princesses\_i))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## cinderella
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(princesses\_i))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## rapunzel
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(princesses\_i))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## belle
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(princesses\_i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <class 'set_iterator'>
\end{verbatim}

\subsubsection{Strings}\label{strings}

using \texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{str1 }\OperatorTok{=} \StringTok{\textquotesingle{}data\textquotesingle{}}
\ControlFlowTok{for}\NormalTok{ my\_char }\KeywordTok{in}\NormalTok{ str1:}
    \BuiltInTok{print}\NormalTok{(my\_char)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## d
## a
## t
## a
\end{verbatim}

\subsubsection{Tuples}\label{tuples}

\texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{metrics }\OperatorTok{=}\NormalTok{ (}\StringTok{\textquotesingle{}auc\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}recall\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}precision\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}support\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ met }\KeywordTok{in}\NormalTok{ metrics:}
    \BuiltInTok{print}\NormalTok{(met)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## auc
## recall
## precision
## support
\end{verbatim}

\subsubsection{Dicts}\label{dicts}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{courses }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}fall\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}regression\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}python\textquotesingle{}}\NormalTok{],}
         \StringTok{\textquotesingle{}spring\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}capstone\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}pyspark\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}nlp\textquotesingle{}}\NormalTok{]\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in}\NormalTok{ courses:}
  \BuiltInTok{print}\NormalTok{(k)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## fall
## spring
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in}\NormalTok{ courses.keys():}
  \BuiltInTok{print}\NormalTok{(k)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## fall
## spring
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ v }\KeywordTok{in}\NormalTok{ courses.values():}
  \BuiltInTok{print}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['regression', 'python']
## ['capstone', 'pyspark', 'nlp']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ k, v }\KeywordTok{in}\NormalTok{ courses.items():}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{k}\SpecialCharTok{.}\NormalTok{upper()}\SpecialCharTok{\}}\SpecialStringTok{:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\StringTok{\textquotesingle{}, \textquotesingle{}}\SpecialCharTok{.}\NormalTok{join(v)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## FALL:    regression, python
## SPRING:  capstone, pyspark, nlp
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in}\NormalTok{ courses.keys():}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{k}\SpecialCharTok{.}\NormalTok{upper()}\SpecialCharTok{\}}\SpecialStringTok{:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\StringTok{\textquotesingle{}, \textquotesingle{}}\SpecialCharTok{.}\NormalTok{join(courses[k])}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{) }\CommentTok{\#index into dict}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## FALL:    regression, python
## SPRING:  capstone, pyspark, nlp
\end{verbatim}

\subsubsection{Ranges}\label{ranges}

using \texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(}\BuiltInTok{str}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{).zfill(}\DecValTok{2}\NormalTok{),(i}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{**}\DecValTok{2}\OperatorTok{*}\StringTok{\textquotesingle{}|\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 01 |
## 02 ||||
## 03 |||||||||
## 04 ||||||||||||||||
## 05 |||||||||||||||||||||||||
\end{verbatim}

\subsection{\texorpdfstring{Get iteration number with \texttt{enumerate()}}{Get iteration number with enumerate()}}\label{get-iteration-number-with-enumerate}

Very often you will want to know iteration number you are on in a loop.

can be used to name files or dict keys, for example.

\texttt{enumerate()} will return the index and key for each iteration.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{courses}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {'fall': ['regression', 'python'], 'spring': ['capstone', 'pyspark', 'nlp']}
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i, semester }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(courses):}
\NormalTok{    course\_name }\OperatorTok{=} \SpecialStringTok{f"}\SpecialCharTok{\{}\BuiltInTok{str}\NormalTok{(i)}\SpecialCharTok{.}\NormalTok{zfill(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{\_}\SpecialCharTok{\{}\NormalTok{semester}\SpecialCharTok{\}}\SpecialStringTok{:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\StringTok{\textquotesingle{}{-}\textquotesingle{}}\SpecialCharTok{.}\NormalTok{join(courses[semester])}\SpecialCharTok{\}}\SpecialStringTok{"}
    \BuiltInTok{print}\NormalTok{(course\_name)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 00_fall: regression-python
## 01_spring:   capstone-pyspark-nlp
\end{verbatim}

\subsection{Nested Loops}\label{nested-loops}

Iterations can be nested, which is very powerful

This works well with nested data structures, like dicts within dicts.

This is basically how \texttt{JSON} files are handles, by the way\ldots{}

Be careful, though, these can get deep and complicated.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i, semester }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(courses):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{i}\OperatorTok{+}\DecValTok{1}\SpecialCharTok{\}}\SpecialStringTok{. }\SpecialCharTok{\{}\NormalTok{semester}\SpecialCharTok{.}\NormalTok{upper()}\SpecialCharTok{\}}\SpecialStringTok{:"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ j, course }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(courses[semester]):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{i}\OperatorTok{+}\DecValTok{1}\SpecialCharTok{\}}\SpecialStringTok{.}\SpecialCharTok{\{}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\SpecialCharTok{\}}\SpecialStringTok{. }\SpecialCharTok{\{}\NormalTok{course}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1. FALL:
##  1.1. regression
##  1.2. python
## 2. SPRING:
##  2.1. capstone
##  2.2. pyspark
##  2.3. nlp
\end{verbatim}

Use nested loops to get the cartesian product.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OperatorTok{=} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{7}\NormalTok{)}
\NormalTok{die\_rolls }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ face1 }\KeywordTok{in}\NormalTok{ die:}
    \ControlFlowTok{for}\NormalTok{ face2 }\KeywordTok{in}\NormalTok{ die:}
\NormalTok{        die\_rolls.append((face1, face2))}
\BuiltInTok{print}\NormalTok{(die\_rolls)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
\end{verbatim}

Now get frequency of die roll sums.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die\_roll\_sums }\OperatorTok{=}\NormalTok{ \{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ my\_die\_roll }\KeywordTok{in}\NormalTok{ die\_rolls:}
\NormalTok{    my\_die\_roll\_sum }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(my\_die\_roll)}
\NormalTok{    die\_roll\_sums[my\_die\_roll\_sum] }\OperatorTok{=}\NormalTok{ die\_roll\_sums.get(my\_die\_roll\_sum, }\DecValTok{0}\NormalTok{) }\OperatorTok{+} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ k, v }\KeywordTok{in}\NormalTok{ die\_roll\_sums.items():}
    \BuiltInTok{print}\NormalTok{(}\BuiltInTok{str}\NormalTok{(k).zfill(}\DecValTok{2}\NormalTok{), v, }\StringTok{\textquotesingle{}|\textquotesingle{}} \OperatorTok{*}\NormalTok{ v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 02 1 |
## 03 2 ||
## 04 3 |||
## 05 4 ||||
## 06 5 |||||
## 07 6 ||||||
## 08 5 |||||
## 09 4 ||||
## 10 3 |||
## 11 2 ||
## 12 1 |
\end{verbatim}

\section{Comprehensions}\label{comprehensions}

\subsection{List Comprehensions}\label{list-comprehensions}

Consider the following task.

Check if each integer in a list is odd and save the results (true or false) in a list.

With a standard loop, you could do this

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vals }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{12}\NormalTok{,}\DecValTok{15}\NormalTok{]}
\NormalTok{is\_odd }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ vals:   }
    \ControlFlowTok{if}\NormalTok{ val }\OperatorTok{\%} \DecValTok{2}\NormalTok{:}
\NormalTok{        is\_odd.append(}\VariableTok{True}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:       }
\NormalTok{        is\_odd.append(}\VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is\_odd}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [True, True, False, False, False, True]
\end{verbatim}

Now do the same with a list comprehension:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is\_odd\_comp }\OperatorTok{=}\NormalTok{ [val }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1} \ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ vals]}
\NormalTok{is\_odd\_comp}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [True, True, False, False, False, True]
\end{verbatim}

Much shorter and if you understand the syntax, quicker to interpret.

Here's how you might save all the odd numbers in a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{odd\_vals }\OperatorTok{=}\NormalTok{ [val }\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ vals }\ControlFlowTok{if}\NormalTok{ val }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1}\NormalTok{]}
\NormalTok{odd\_vals}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 5, 15]
\end{verbatim}

\subsection{Comprehensions in General}\label{comprehensions-in-general}

Comprehensions provide a concise method for iterating over any iterable object to a new iterable object.

There are comprehensions for each type of iterable:

\begin{itemize}
\tightlist
\item
  List comprehensions
\item
  Dict comprehensions
\item
  Set comprehensions
\end{itemize}

\textbf{Note}: there is no tuple comprehension.

Comprehensions are essentially concise \texttt{for} loops that address the use case of \emph{transforming one iterable into another}.

They are also more efficient than loops.

All comprehensions have the form:

listlike\_result = \texttt{{[}expression\ +\ context\ +\ condition{]}}

For example, in the comprehension above we can see these parts by breaking up the code into three lines:

This is syntactically legit.

The type of comprehension is indicated by the use of enclosing pairs, just like anonymous constructors:

\begin{itemize}
\tightlist
\item
  List comprehensions: \texttt{{[}expression\ +\ context\ +\ condition{]}}
\item
  Dict comprehensions: \texttt{\{expression\ +\ context\ +\ condition\}}
\item
  Set comprehensions: \texttt{\{expression\ +\ context\ +\ condition\}}
\end{itemize}

Parts:

\begin{itemize}
\item
  \textbf{Expression} defines what to do with each element in the list.

  \begin{itemize}
  \tightlist
  \item
    this can be a complex expression, or it may not include the iterated value at all
  \item
    for dicts, the expression is actually complex, it must be a key/value pair
  \end{itemize}
\item
  \textbf{Context} defines which iterable elements to select
\item
  \textbf{Condition} defiens a boolean condition on the iterated value that determines if it gets included in the expression
\end{itemize}

Note that you can include comprehensions within comprehensions

And you can include multiple context + condition statements

\subsection{Examples}\label{examples}

\subsubsection{Removing Stopwords}\label{removing-stopwords}

Define a sentence and a list of stop words.

Filter out stop words (considered not important).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sentence }\OperatorTok{=} \StringTok{"I am not a fan of this film"}
\NormalTok{stop\_words }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}am\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}an\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}i\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}the\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}of\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clean\_words }\OperatorTok{=}\NormalTok{ [word }\ControlFlowTok{for}\NormalTok{ word }\KeywordTok{in}\NormalTok{ sentence.split() }\ControlFlowTok{if}\NormalTok{ word.lower() }\KeywordTok{not} \KeywordTok{in}\NormalTok{ stop\_words]}
\NormalTok{clean\_words}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['not', 'fan', 'this', 'film']
\end{verbatim}

\textbf{Side note}: this task can be accomplished with sets, if not concerned with multiple instances of the same word.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(stop\_words)}
\NormalTok{s2 }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(sentence.lower().split())}
\NormalTok{s2}\OperatorTok{{-}}\NormalTok{s1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {'film', 'not', 'this', 'fan'}
\end{verbatim}

\subsubsection{Selecting Tokens Containing Units}\label{selecting-tokens-containing-units}

Given list of measurements, retain elements containing \emph{mmHg} (millimeters of mercury)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{units }\OperatorTok{=} \StringTok{\textquotesingle{}mmHg\textquotesingle{}}
\NormalTok{measures }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}20\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}115mmHg\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}5mg\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}10 mg\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}7.5dl\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}120 mmHg\textquotesingle{}}\NormalTok{]}
\NormalTok{measures\_mmhg }\OperatorTok{=}\NormalTok{ [measure }\ControlFlowTok{for}\NormalTok{ measure }\KeywordTok{in}\NormalTok{ measures }\ControlFlowTok{if}\NormalTok{ units }\KeywordTok{in}\NormalTok{ measure]}

\NormalTok{measures\_mmhg}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['115mmHg', '120 mmHg']
\end{verbatim}

\textbf{Filtering on Two Conditions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{units1 }\OperatorTok{=} \StringTok{\textquotesingle{}mmHg\textquotesingle{}}
\NormalTok{units2 }\OperatorTok{=} \StringTok{\textquotesingle{}dl\textquotesingle{}}
\NormalTok{meas\_mmhg\_dl }\OperatorTok{=}\NormalTok{ [meas }\ControlFlowTok{for}\NormalTok{ meas }\KeywordTok{in}\NormalTok{ measures }\ControlFlowTok{if}\NormalTok{ units1 }\KeywordTok{in}\NormalTok{ meas }\KeywordTok{or}\NormalTok{ units2 }\KeywordTok{in}\NormalTok{ meas]}

\NormalTok{meas\_mmhg\_dl}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['115mmHg', '7.5dl', '120 mmHg']
\end{verbatim}

This can be written differently for clarity:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[meas }
 \ControlFlowTok{for}\NormalTok{ meas }\KeywordTok{in}\NormalTok{ measures }
 \ControlFlowTok{if}\NormalTok{ units1 }\KeywordTok{in}\NormalTok{ meas }
 \KeywordTok{or}\NormalTok{ units2 }\KeywordTok{in}\NormalTok{ meas]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ['115mmHg', '7.5dl', '120 mmHg']
\end{verbatim}

\subsubsection{Dict Comprehensions}\label{dict-comprehensions}

\textbf{Dict comprehensions} provide a concise method for iterating over a dict to create a new dict

This is common when data is structured as key-value pairs, and we'd like to filter the dict.

Here we define various deep learning models and their depths (in layers).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{model\_arch }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}cnn\_1\textquotesingle{}}\NormalTok{:}\DecValTok{15}\NormalTok{,}\StringTok{\textquotesingle{}cnn\_2\textquotesingle{}}\NormalTok{:}\DecValTok{20}\NormalTok{,}\StringTok{\textquotesingle{}rnn\textquotesingle{}}\NormalTok{:}\DecValTok{10}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

we use a comprehension to create a new dict containing only key-value pairs where the key contains the string \texttt{cnn}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cnns }\OperatorTok{=}\NormalTok{ \{key:model\_arch[key] }\ControlFlowTok{for}\NormalTok{ key }\KeywordTok{in}\NormalTok{ model\_arch.keys() }\ControlFlowTok{if} \StringTok{\textquotesingle{}cnn\textquotesingle{}} \KeywordTok{in}\NormalTok{ key\}}

\NormalTok{cnns}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {'cnn_1': 15, 'cnn_2': 20}
\end{verbatim}

We build the key-value pairs using \texttt{key:model\_arch{[}key{]}}, where key indexes into the dict \texttt{model\_arch}.

\section{Nested Comprehensions}\label{nested-comprehensions}

Recall that nested loops are the algorithmic complement to nested data structures.

Just as we can nest loops using \texttt{for} loops, we can do so with comprehensions

Here are some examples:

\subsection{Example 1: Creating a Matrix}\label{example-1-creating-a-matrix}

Here is how we can make a matrix - a two dimensional data structure where each element is of the same data type - using plain old \texttt{for} loops.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix1 }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# Matrix created}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
\NormalTok{    matrix1.append([]) }\CommentTok{\# Row created}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
\NormalTok{        matrix1[i].append(j) }\CommentTok{\# Cell populated}
        
\NormalTok{matrix1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]
\end{verbatim}

Here's how we can do it with a nested list comprehension:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix2 }\OperatorTok{=}\NormalTok{ [[j }\ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{)] }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{ (}\DecValTok{5}\NormalTok{)]}

\NormalTok{matrix2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]
\end{verbatim}

Replacing five lines of code with just one.

\subsection{Example 2: Filtering a Nested List:}\label{example-2-filtering-a-nested-list}

Create a filter to extract some things we want from a matrix.

In this case we want to pull out all the odd numbers and save them as a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix3 }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]]}
\NormalTok{odd\_numbers1 }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ row }\KeywordTok{in}\NormalTok{ matrix3:}
    \ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ row:}
        \ControlFlowTok{if}\NormalTok{ element }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{:}
\NormalTok{            odd\_numbers1.append(element)}

\NormalTok{odd\_numbers1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 5, 7, 9]
\end{verbatim}

Now do it with a comprehension

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{odd\_numbers2 }\OperatorTok{=}\NormalTok{ [element }\ControlFlowTok{for}\NormalTok{ row }\KeywordTok{in}\NormalTok{ matrix3 }\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ row }\ControlFlowTok{if}\NormalTok{ element }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{]}

\NormalTok{odd\_numbers2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 5, 7, 9]
\end{verbatim}

Compare the traditional \texttt{for} loop way:

with the comprehension (inside \texttt{{[}{]}}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{element                        }
    \ControlFlowTok{for}\NormalTok{ row }\KeywordTok{in}\NormalTok{ matrix3 }
        \ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ row }
            \ControlFlowTok{if}\NormalTok{ element }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

See how they are the same, except that the kernel operation - appending filtered values to a result list - is hoisted to the top in the case of the comprehension.

\subsection{Example 3: Flattening Nested Sub-Lists}\label{example-3-flattening-nested-sub-lists}

Here we take a nested structure and flatten it out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nested\_list }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{], [}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]]}
\NormalTok{flat\_list1 }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ sub\_list }\KeywordTok{in}\NormalTok{ nested\_list:}
    \ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ sub\_list:}
\NormalTok{        flat\_list1.append(val)}

\NormalTok{flat\_list1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{verbatim}

Comprehension:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flat\_list2 }\OperatorTok{=}\NormalTok{ [val }\ControlFlowTok{for}\NormalTok{ sub\_list }\KeywordTok{in}\NormalTok{ nested\_list }\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ sub\_list]}

\NormalTok{flat\_list2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{verbatim}

\subsection{Example 4: Manipulating Matrix Values}\label{example-4-manipulating-matrix-values}

Finally, we demonstrate how to manipulate each value in a matrix of words.

In this case, we simply capitalize each string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix4 }\OperatorTok{=}\NormalTok{ [[}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"cherry"}\NormalTok{],}
\NormalTok{        [}\StringTok{"date"}\NormalTok{, }\StringTok{"fig"}\NormalTok{, }\StringTok{"grape"}\NormalTok{],}
\NormalTok{        [}\StringTok{"kiwi"}\NormalTok{, }\StringTok{"lemon"}\NormalTok{, }\StringTok{"mango"}\NormalTok{]]}
\NormalTok{modified\_matrix1 }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ row }\KeywordTok{in}\NormalTok{ matrix4:}
\NormalTok{    modified\_row }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ fruit }\KeywordTok{in}\NormalTok{ row:}
\NormalTok{        modified\_row.append(fruit.capitalize())}
\NormalTok{    modified\_matrix1.append(modified\_row)}
    
\NormalTok{modified\_matrix1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [['Apple', 'Banana', 'Cherry'], ['Date', 'Fig', 'Grape'], ['Kiwi', 'Lemon', 'Mango']]
\end{verbatim}

Comprehension:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{modified\_matrix2 }\OperatorTok{=}\NormalTok{ [[fruit.capitalize() }\ControlFlowTok{for}\NormalTok{ fruit }\KeywordTok{in}\NormalTok{ row] }\ControlFlowTok{for}\NormalTok{ row }\KeywordTok{in}\NormalTok{ matrix4]}

\NormalTok{modified\_matrix2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [['Apple', 'Banana', 'Cherry'], ['Date', 'Fig', 'Grape'], ['Kiwi', 'Lemon', 'Mango']]
\end{verbatim}

  \bibliography{book.bib}

\end{document}
